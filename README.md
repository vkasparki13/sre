> у нас мультизональный кластер (три зоны), в котором пять нод

Допустим, что ноды распределены по зонам 2:2:1, в связи с этим `spec.topologySpreadConstraints.maxSkew=1`.
> на первые запросы приложению требуется значительно больше ресурсов CPU, в дальнейшем потребление ровное в районе 0.1 CPU. По памяти всегда “ровно” в районе 128M memory

В таком случае лимиты по CPU не указываем. Пусть на старте использует сколько доступно на ноде.
> приложение имеет дневной цикл по нагрузке – ночью запросов на порядки меньше, пик – днём

Исходя из этого напрашивается HPA. Спека в `hpa.yaml`. Но в использовании HPA есть недостаток. При скейле вниз он оперирует только метриками. То есть вполне может получиться так, что два пода останутся в рамках одной зоны доступности (у нас 4 пода в трёх зонах, то есть две реплики будут в одной зоне, при даунскейле HPA может убить два пода из двух разных зон и в итоге два пода останутся в одной зоне). Здесь уже стоит выбирать что важнее: экономия ресурсов или отказоустойчивость. Если первое, то такое вариант с HPA видится неплохим. Если второе, то HPA я бы в целом не использовал.

Решил использовать комбинации меток `topology.kubernetes.io/zone` и `kubernetes.io/hostname`. Чтобы разместить поды равномерно по зонам и исключить размещение нескольких подов на одной ноде.

>у нас мультизональный кластер (три зоны), в котором пять нод

Будем считать, что узлы находятся в группе фиксированного размера. Если предположить, что подам может не хватить ресурсов для размещения на узлах, то можно ещё создать `PriorityClass` и задать его для пода в `spec.containers.priorityClassName`. Тогда шедулер вытеснит менее приоритетные поды и запланирует поды деплоймента `web`.
